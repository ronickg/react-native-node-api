import assert from "node:assert/strict";
import fs from "node:fs";
import path from "node:path";
import cp from "node:child_process";

import {
  type NodeApiVersion,
  symbols,
  include_dir as nodeApiIncludePath,
} from "node-api-headers";
import { z } from "zod";

export const WEAK_NODE_API_PATH = path.join(__dirname, "../weak-node-api");

export function getNodeApiSymbols(
  version: NodeApiVersion,
  filter?: "js_native_api_symbols" | "node_api_symbols"
) {
  const symbolsPerInterface = symbols[version];
  if (filter === "js_native_api_symbols") {
    return symbolsPerInterface.js_native_api_symbols;
  } else if (filter === "node_api_symbols") {
    return symbolsPerInterface.node_api_symbols;
  } else {
    return [
      ...symbolsPerInterface.js_native_api_symbols,
      ...symbolsPerInterface.node_api_symbols,
    ];
  }
}

export function generateVersionScript(
  libraryName: string,
  globalSymbols: string[]
) {
  return [
    `${libraryName} {`,
    `  global:`,
    ...globalSymbols.map((symbol) => `    ${symbol};`),
    `  local: *;`,
    `};`,
  ].join("\n");
}

const clangAstDump = z.object({
  kind: z.literal("TranslationUnitDecl"),
  inner: z.array(
    z.object({
      kind: z.string(),
      name: z.string().optional(),
      type: z
        .object({
          qualType: z.string(),
        })
        .optional(),
    })
  ),
});

/**
 * Generates source code for a version script for the given Node API version.
 * @param version
 */
export function getNodeApiHeaderAST(version: NodeApiVersion) {
  const output = cp.execFileSync(
    "clang",
    [
      // Declare the Node API version
      "-D",
      `NAPI_VERSION=${version.replace(/^v/, "")}`,
      // Pass the next option directly to the Clang frontend
      "-Xclang",
      // Ask the Clang frontend to dump the AST
      "-ast-dump=json",
      // Parse and analyze the source file but not compile it
      "-fsyntax-only",
      // Include from the node-api-headers package
      `-I${nodeApiIncludePath}`,
      path.join(nodeApiIncludePath, "node_api.h"),
    ],
    {
      encoding: "utf-8",
      // Emitting the AST can produce a lot of output
      maxBuffer: 1024 * 1024 * 10,
    }
  );
  const parsed = JSON.parse(output);
  return clangAstDump.parse(parsed);
}

/**
 * Generates source code for a version script for the given Node API version.
 * @param version
 */
export function generateFakeNodeApiSource(version: NodeApiVersion) {
  const lines = [
    "// This file is generated by react-native-node-api-modules",
    "#include <node_api.h>",
  ];
  const root = getNodeApiHeaderAST(version);
  assert.equal(root.kind, "TranslationUnitDecl");
  assert(Array.isArray(root.inner));
  const foundSymbols = new Set();
  const nodeApiSymbols = new Set(getNodeApiSymbols(version));
  for (const node of root.inner) {
    if (
      node.kind === "FunctionDecl" &&
      node.name &&
      nodeApiSymbols.has(node.name)
    ) {
      foundSymbols.add(node.name);

      assert(node.type, `Expected type for ${node.name}`);

      const match = node.type.qualType.match(
        /^(?<returnType>[^(]+) \((?<argumentTypes>[^)]+)\)/
      );
      assert(
        match && match.groups,
        `Failed to parse function type: ${node.type.qualType}`
      );
      const { returnType, argumentTypes } = match.groups;
      assert(
        returnType,
        `Failed to get return type from ${node.type.qualType}`
      );
      assert(
        argumentTypes,
        `Failed to get argument types from ${node.type.qualType}`
      );
      assert(
        returnType === "napi_status" || returnType === "void",
        `Expected return type to be napi_status, got ${returnType}`
      );
      lines.push(
        `__attribute__((weak)) ${returnType} ${node.name}(${argumentTypes}) {`,
        returnType === "void" ? "" : "  napi_status::napi_generic_failure;",
        "}"
      );
    }
  }
  for (const knownSymbol of nodeApiSymbols) {
    if (!foundSymbols.has(knownSymbol)) {
      throw new Error(
        `Missing symbol '${knownSymbol}' in the AST for Node API ${version}`
      );
    }
  }
  return lines.join("\n");
}

export async function ensureNodeApiVersionScript(version: NodeApiVersion) {
  const outputPath = path.join(WEAK_NODE_API_PATH, `fakenode-${version}.map`);
  if (!fs.existsSync(outputPath)) {
    // Make sure the output directory exists
    fs.mkdirSync(WEAK_NODE_API_PATH, { recursive: true });
    const symbols = getNodeApiSymbols(version);
    const content = generateVersionScript("libfakenode", symbols);
    fs.writeFileSync(outputPath, content, "utf-8");
  }
  return outputPath;
}

async function run() {
  const sourceCode = generateFakeNodeApiSource("v10");
  await fs.promises.mkdir(WEAK_NODE_API_PATH, { recursive: true });
  await fs.promises.writeFile(
    path.join(WEAK_NODE_API_PATH, "weak-node-api.cpp"),
    sourceCode,
    "utf-8"
  );
  // Build for all supported platforms
  cp.spawnSync(
    "react-native-node-api-cmake",
    [
      "--android",
      "--apple",
      "--no-auto-link",
      "--no-weak-node-api-linkage",
      "--source",
      WEAK_NODE_API_PATH,
    ],
    { stdio: "inherit" }
  );
}

run().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
